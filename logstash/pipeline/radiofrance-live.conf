input {
  kafka {
    bootstrap_servers => "kafka:9092"
    topics => ["radiofrance-live"]
    codec => "json"
    consumer_threads => 1
    decorate_events => true
    group_id => "logstash-radiofrance"
  }
}

filter {
  # Parse JSON message body
  json {
    source => "message"
    skip_on_invalid_json => true
  }

# Rename geo_location to location for Elasticsearch geo_point mapping
  # The collector already provides geo_location with {lat, lon} for France Bleu stations
  if [geo_location] {
    mutate {
      rename => { "geo_location" => "location" }
    }
  }

  # Extract nested fields to top level for easier querying
  if [current_show] {
    mutate {
      add_field => {
        "show_title" => "%{[current_show][show_title]}"
        "episode_title" => "%{[current_show][title]}"
        "show_url" => "%{[current_show][url]}"
      }
    }

    # Extract description if present
    if [current_show][description] {
      mutate {
        add_field => { "description" => "%{[current_show][description]}" }
      }
    }

    # Extract podcast availability
    if [current_show][has_podcast] {
      mutate {
        add_field => { "has_podcast" => "%{[current_show][has_podcast]}" }
      }
      mutate {
        convert => { "has_podcast" => "boolean" }
      }
    }
  }

  # Extract track information if present
  if [current_track] {
    mutate {
      add_field => {
        "track_title" => "%{[current_track][title]}"
        "artist" => "%{[current_track][musical_group_name]}"
      }
    }

    if [current_track][album_title] {
      mutate {
        add_field => { "album" => "%{[current_track][album_title]}" }
      }
    }

    if [current_track][year] {
      mutate {
        add_field => { "release_year" => "%{[current_track][year]}" }
      }
      mutate {
        convert => { "release_year" => "integer" }
      }
    }

    if [current_track][label] {
      mutate {
        add_field => { "music_label" => "%{[current_track][label]}" }
      }
    }
  }

  # Parse broadcast timestamps
  if [broadcast_start] {
    date {
      match => ["broadcast_start", "ISO8601"]
      target => "broadcast_start_time"
      timezone => "UTC"
    }
  }

  if [broadcast_end] {
    date {
      match => ["broadcast_end", "ISO8601"]
      target => "broadcast_end_time"
      timezone => "UTC"
    }
  }

  if [snapshot_time] {
    date {
      match => ["snapshot_time", "ISO8601"]
      target => "@timestamp"
      timezone => "UTC"
    }
  }

  # Compute if broadcast is currently live
  ruby {
    code => '
      now = Time.now.utc
      if event.get("broadcast_start_time") && event.get("broadcast_end_time")
        start_time = event.get("broadcast_start_time")
        end_time = event.get("broadcast_end_time")
        if start_time <= now && now <= end_time
          event.set("is_currently_live", true)
        else
          event.set("is_currently_live", false)
        end
      end
    '
  }

  # Add theme count for analytics
  if [themes] {
    ruby {
      code => '
        themes = event.get("themes")
        if themes && themes.is_a?(Array)
          event.set("theme_count", themes.length)

          # Extract top-level theme categories
          categories = themes.map { |t| t.split("/").first }.uniq
          event.set("theme_categories", categories)
        end
      '
    }
  }

  # Add station brand (main group)
  if [station_id] {
    if [station_id] =~ /^FRANCEINTER/ {
      mutate { add_field => { "station_brand" => "France Inter" } }
    } else if [station_id] =~ /^FRANCECULTURE/ {
      mutate { add_field => { "station_brand" => "France Culture" } }
    } else if [station_id] =~ /^FRANCEMUSIQUE/ {
      mutate { add_field => { "station_brand" => "France Musique" } }
    } else if [station_id] =~ /^FRANCEINFO/ {
      mutate { add_field => { "station_brand" => "France Info" } }
    } else if [station_id] =~ /^FIP/ {
      mutate { add_field => { "station_brand" => "FIP" } }
    } else if [station_id] =~ /^FRANCEBLEU/ {
      mutate { add_field => { "station_brand" => "France Bleu" } }
    } else if [station_id] =~ /^MOUV/ {
      mutate { add_field => { "station_brand" => "Mouv" } }
    }
  }

  # Clean up fields with literal %{...} when they're missing
  ruby {
    code => '
      event.to_hash.each do |key, value|
        if value.is_a?(String) && value.start_with?("%{") && value.end_with?("}")
          event.remove(key)
        end
      end
    '
  }

  # Remove Kafka metadata we don't need
  mutate {
    remove_field => ["@version", "message"]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "radiofrance-live-%{+YYYY.MM.dd}"
    document_id => "%{station_id}_%{snapshot_time}"
  }

  # For debugging - can be removed in production
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}
